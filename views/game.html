<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Game Playground</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
        }
        
        .playground-area {
            width: 90vw;
            height: 80vh;
            background: rgba(255, 255, 255, 0.95);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            position: relative;
            margin: 20px 0;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .game-row {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border-bottom: 1px solid rgba(0, 0, 0, 0.1);
        }

        #row2,
        #row5,
        #row6 {
            border-bottom: none;
        }
        
        .card {
            width: 70px;
            height: 140px;
            border-radius: 8px;
            position: absolute;
            cursor: move;
            z-index: 1000;
            border: 2px solid rgba(255, 255, 255, 0.8);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            user-select: none;
            transform-origin: center center;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: scale(1.5);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
            border-color: rgba(255, 255, 255, 1);
            transition: all 0.1s ease;
        }
        
        .card.dragging {
            transform: scale(1.3);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 2000;
            border-color: rgba(255, 255, 255, 1);
            transition: none;
        }
        
        .card.in-deck {
            cursor: default;
            pointer-events: none;
            opacity: 0;
            display: none;
        }
        
        .deck-placeholder {
            width: 70px;
            height: 140px;
            border: 2px dashed rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: rgba(0, 0, 0, 0.5);
            font-weight: bold;
        }

        .stack {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 100px;
            height: 200px;
            background: rgba(255, 0, 0, 0.15);
            border-left: 2px solid red;
            display: flex;
            align-items: center;
            justify-content: center;
            color: red;
            font-weight: bold;
            pointer-events: none; /* Allow dragging over it */
            z-index: 5000;
        }
    </style>
</head>
<body>
    <h1 class="title">Working Title asdf</h1>
        
    <div class="playground-area" id="playgroundArea">
        <div class="game-row" id="row1"></div>
        <div class="game-row" id="row2"></div>
        <div class="game-row" id="row3"></div>
        <div class="game-row" id="row4">
            <div class="deck-placeholder" id="deckPlaceholder">DECK</div>
        </div>
        <div class="game-row" id="row5"></div>
        <div class="game-row" id="row6"></div>
        <div class="game-row" id="row7"></div>
        <div class="stack" id="stack">Stack</div>
    </div>

    <script>
        class CardGamePlayground {
            constructor() {
                this.playgroundArea = document.getElementById('playgroundArea');
                this.deckPlaceholder = document.getElementById('deckPlaceholder');
                this.stack = document.getElementById('stack');
                
                this.deck = [];
                this.stack = [];
                this.topHand = [];
                this.topField = [];
                this.bottomHand = [];
                this.bottomField = [];
                this.isDragging = false;
                this.currentDragCard = null;
                this.dragOffset = { x: 0, y: 0 };
                this.mousePosition = { x: 0, y: 0 };
                
                // Constants
                this.TOTAL_CARDS = 60;
                this.CARD_WIDTH = 70;
                this.CARD_HEIGHT = 140;
                this.MAX_ROTATION = 25;
                this.HOVER_DISTANCE = 50; // Distance threshold for hover detection
                
                this.init();
            }
            
            init() {
                this.setupEventListeners();
                // Delay initialization to ensure DOM is ready
                setTimeout(() => this.initializeGame(), 100);
            }
            
            setupEventListeners() {
                // Use bound methods to maintain context and enable cleanup
                this.boundDrag = this.drag.bind(this);
                this.boundStopDrag = this.stopDrag.bind(this);
                this.boundHandleResize = this.handleResize.bind(this);
                this.boundTrackMouse = this.trackMouse.bind(this);
                
                document.addEventListener('mousemove', this.boundDrag, { passive: false });
                document.addEventListener('mousemove', this.boundTrackMouse, { passive: true });
                document.addEventListener('mouseup', this.boundStopDrag);
                window.addEventListener('resize', this.boundHandleResize);
            }
            
            initDeck() {
                const colors = [];
                for (let i = 0; i < this.TOTAL_CARDS; i++) {
                    const hue = (i * 360) / this.TOTAL_CARDS;
                    const saturation = 70 + (i % 3) * 10;
                    const lightness = 50 + (i % 4) * 10;
                    colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
                }

                colors.forEach((color) => {
                    const card = this.createCard(color);
                    this.addToDeck(card);
                });
            }

            shuffle() {
                const indices = Array.from({length: this.deck.length}, (_, i) => i);
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }
                // TODO: actually apply the shuffle
            }

            initializeGame() {
                const playgroundWidth = this.playgroundArea.offsetWidth;
                const playgroundHeight = this.playgroundArea.offsetHeight;
                
                this.deck = this.initDeck();
                this.shuffle();
                
                for (let i = 0; i < 7; i++) {
                    this.draw(True);
                }

                for (let i = 0; i < 7; i++) {
                    this.draw(False);
                }
            }

            createCard(color) {
                const rect = document.createElement('div');
                rect.className = 'card';
                rect.style.backgroundColor = color;
                rect.style.left = x + 'px';
                rect.style.top = y + 'px';
                
                this.playgroundArea.appendChild(rect);
                
                const card = {
                    element: rect,
                    isDragging: false,
                    color: color,
                    pos: "deck", // deck, stack, topHand, topField, bottomHand, bottomField
                };
                
                rect.addEventListener('mousedown', (e) => this.startDrag(e, card));
                
                return card;
            }

            addToDeck(card) {
                this.deck.unshift(card);
                card.element.classList.add('in-deck');
                card.pos = "deck";
            }

            getFromDeck() {
                const card = this.deck.shift();
                card.element.classList.remove('in-deck');
            }

            draw(top) {
                const card = this.cardFromDeck();
                if (top) {
                    card.pos = "topHand";
                    this.topHand.unshift(card);
                } else {
                    card.pos = "bottomHand";
                    this.bottomHand.unshift(card);
                }
                this.playgroundArea.appendChild(card.element);
                
                setTimeout(() => this.reposition(), 50);
                setTimeout(() => this.updateDeckDisplay(), 60);
                // if (row === 0) {
                //     // Add to top row and reposition all top row cards
                //     const x = (this.playgroundArea.offsetWidth / 2) - (this.CARD_WIDTH / 2);
                //     const y = 30;
                //     card.element.style.left = x + 'px';
                //     card.element.style.top = y + 'px';
                    
                // } else {
                //     // Add to bottom row and reposition all bottom row cards
                //     const x = (this.playgroundArea.offsetWidth / 2) - (this.CARD_WIDTH / 2);
                //     const y = this.playgroundArea.offsetHeight - 100;
                //     card.element.style.left = x + 'px';
                //     card.element.style.top = y + 'px';                  
                // }
            }
            
            trackMouse(e) {
                this.mousePosition.x = e.clientX;
                this.mousePosition.y = e.clientY;
                
                // TODO: Make card near mouse bigger or something
                // this.topHand.forEach(card => {
                //     this.updateCardRotation(card);
                // });
                // this.bottomHand.forEach(card => {
                //     this.updateCardRotation(card);
                // });
            }
            
            isCardNearCursor(card) {
                const rect = card.element.getBoundingClientRect();
                const cardCenterX = rect.left + rect.width / 2;
                const cardCenterY = rect.top + rect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(this.mousePosition.x - cardCenterX, 2) + 
                    Math.pow(this.mousePosition.y - cardCenterY, 2)
                );
                
                return distance < this.HOVER_DISTANCE;
            }

            // calculateRotation(x, isTopRow = false) {
            //     const screenWidth = window.innerWidth;
            //     const relativePosition = Math.max(-1, Math.min(1, (x - screenWidth / 2) / (screenWidth / 2)));
            //     const baseRotation = relativePosition * this.MAX_ROTATION;
            //     return isTopRow ? -baseRotation : baseRotation;
            // }
            
            // getCardRow(card) {
            //     const rect = card.element.getBoundingClientRect();
            //     const playgroundRect = this.playgroundArea.getBoundingClientRect();
            //     const relativeY = rect.top - playgroundRect.top;
            //     const playgroundHeight = this.playgroundArea.offsetHeight;
            //     const rowHeight = playgroundHeight / 7;
                
            //     const rowIndex = Math.floor(relativeY / rowHeight);
            //     return Math.max(0, Math.min(6, rowIndex)); // Clamp to 0-6 (rows 1-7)
            // }
            
            // updateCardRotation(card) {
            //     const row = this.getCardRow(card);
            //     if (row === 0 || row === 6) {
            //         const rect = card.element.getBoundingClientRect();
            //         const centerX = rect.left + rect.width / 2;
            //         const rotation = this.calculateRotation(centerX, isTopRow);
            //         card.element.style.transform = `rotate(${rotation}deg)`;
            //     } else {
            //         card.element.style.transform = "rotate(0deg)";
            //     }
            // }
            
            updateDeckDisplay() {
                const deckCount = this.deck.length;
                this.deckPlaceholder.textContent = deckCount === 0 ? 'EMPTY' : `DECK (${deckCount})`;
                this.deckPlaceholder.style.opacity = deckCount === 0 ? '0.5' : '1';
            }
            
            repositionCards() {     
                this.topHand.forEach(card => {

                });
                this.topField.forEach(card => {

                });
                // TODO: position

            }
            
            // positionCardsInRow(cards, y) {
            //     if (cards.length === 0) return;
                
            //     const playgroundWidth = this.playgroundArea.offsetWidth;
            //     const spacing = cards.length > 1 ? Math.min(80, (playgroundWidth - 100) / (cards.length - 1)) : 0;
            //     const totalWidth = (cards.length - 1) * spacing;
            //     const startX = (playgroundWidth - totalWidth) / 2 - (this.CARD_WIDTH / 2);
                
            //     cards.forEach((rectangleObj, i) => {
            //         const x = startX + i * spacing;
            //         rectangleObj.element.style.left = x + 'px';
            //         rectangleObj.element.style.top = y + 'px';
                    
            //         // Update original position and row
            //         rectangleObj.originalPosition = { x: x, y: y };
            //         rectangleObj.originalRow = this.getCardRow(rectangleObj);
                    
            //         this.updateCardRotation(rectangleObj);
            //     });
            // }
            
            // positionRowCards(indices, colors, playgroundWidth, y) {
            //     const spacing = 80;
            //     const totalWidth = (indices.length - 1) * spacing;
            //     const startX = (playgroundWidth - totalWidth) / 2 - (this.CARD_WIDTH / 2);
                
            //     indices.forEach((colorIndex, i) => {
            //         const x = startX + i * spacing;
            //         const rectangle = this.createRectangle(colors[colorIndex], x, y);
            //         this.rectangles.push(rectangle);
            //         this.updateCardRotation(rectangle);
            //     });
            // }
            
            isOverDeck(x, y) {
                const deckRect = this.deckArea.getBoundingClientRect();
                return x >= deckRect.left && x <= deckRect.right && 
                       y >= deckRect.top && y <= deckRect.bottom;
            }

            isOverBlocker(x, y) {
                const blockerRect = this.drop-blocker.getBoundingClientRect();
                return x >= blockerRect.left && x <= blockerRect.right && 
                       y >= blockerRect.top && y <= blockerRect.bottom;
            }
            
            startDrag(e, rectangleObj) {
                if (this.deck.includes(rectangleObj)) return;

                const row = rectangleObj.originalRow;
                if (row !== 0 && row !== 6) return;
                
                this.isDragging = true;
                this.currentDragCard = rectangleObj;
                rectangleObj.isDragging = true;
                rectangleObj.element.classList.add('dragging');
                
                const rect = rectangleObj.element.getBoundingClientRect();
                const playgroundRect = this.playgroundArea.getBoundingClientRect();
                rectangleObj.originalPosition = {
                    x: rect.left - playgroundRect.left,
                    y: rect.top - playgroundRect.top
                };
                rectangleObj.originalRow = this.getCardRow(rectangleObj);
                
                const rectRect = rectangleObj.element.getBoundingClientRect();
                this.dragOffset.x = e.clientX - rectRect.left;
                this.dragOffset.y = e.clientY - rectRect.top;
                
                e.preventDefault();
            }
            
            drag(e) {
                if (!this.isDragging || !this.currentDragCard) return;
                
                const playgroundRect = this.playgroundArea.getBoundingClientRect();
                
                let x = e.clientX - playgroundRect.left - this.dragOffset.x;
                let y = e.clientY - playgroundRect.top - this.dragOffset.y;
                
                // Clamp to playground bounds
                x = Math.max(0, Math.min(playgroundRect.width - this.CARD_WIDTH, x));
                y = Math.max(0, Math.min(playgroundRect.height - this.CARD_HEIGHT, y));
                
                this.currentDragCard.element.style.left = x + 'px';
                this.currentDragCard.element.style.top = y + 'px';
            }
            
            // Change 2: Check if move is valid based on original row
            isValidMove(rectangleObj, targetRow) {
                const originalRow = rectangleObj.originalRow;
                
                // Top row (row 0) can only move to rows 1-2 (second and third rows)
                if (originalRow === 0) {
                    return targetRow === 1 || targetRow === 2;
                }
                
                // Bottom row (row 6) can only move to rows 4-5 (fifth and sixth rows)
                if (originalRow === 6) {
                    return targetRow === 4 || targetRow === 5;
                }
                
                // Cards from other rows can move anywhere
                return true;
            }
            
            stopDrag(e) {
                if (!this.isDragging || !this.currentDragCard) return;
                
                this.isDragging = false;
                this.currentDragCard.isDragging = false;
                this.currentDragCard.element.classList.remove('dragging');
                
                if (this.isOverBlocker(e.clientX, e.clientY)) {
                    this.currentDragCard.element.style.left = this.currentDragCard.originalPosition.x + 'px';
                    this.currentDragCard.element.style.top = this.currentDragCard.originalPosition.y + 'px';
                } else if (this.isOverDeck(e.clientX, e.clientY)) {
                    this.addToDeck(this.currentDragCard);
                } else {
                    // Change 2: Check if the move is valid
                    const currentRow = this.getCardRow(this.currentDragCard);
                    const isValidMove = this.isValidMove(this.currentDragCard, currentRow);
                    
                    if (!isValidMove) {
                        // Return card to original position
                        this.currentDragCard.element.style.left = this.currentDragCard.originalPosition.x + 'px';
                        this.currentDragCard.element.style.top = this.currentDragCard.originalPosition.y + 'px';
                    } else {
                        // Ensure card stays in playground
                        if (this.currentDragCard.element.parentElement !== this.playgroundArea) {
                            this.playgroundArea.appendChild(this.currentDragCard.element);
                        }
                        
                        // Change 3: If card was moved to/from top or bottom row, reposition cards
                        const newRow = this.getCardRow(this.currentDragCard);
                        if (this.currentDragCard.originalRow === 0 || this.currentDragCard.originalRow === 6 || 
                            newRow === 0 || newRow === 6) {
                            setTimeout(() => this.repositionRowCards(), 50);
                        }
                    }
                    
                    this.updateCardRotation(this.currentDragCard);
                }
                
                this.currentDragCard = null;
            }
            
            handleResize() {
                // Throttle resize handling
                if (this.resizeTimeout) return;
                
                this.resizeTimeout = setTimeout(() => {
                    this.cards.forEach(card => {
                        if (!card.isDragging) {
                            this.updateCardRotation(rectangleObj);
                        }
                    });
                    // Change 3: Reposition cards after resize
                    this.repositionRowCards();
                    this.resizeTimeout = null;
                }, 100);
            }
            
            // Cleanup method for potential memory leaks
            destroy() {
                document.removeEventListener('mousemove', this.boundDrag);
                document.removeEventListener('mousemove', this.boundTrackMouse);
                document.removeEventListener('mouseup', this.boundStopDrag);
                window.removeEventListener('resize', this.boundHandleResize);
                
                if (this.resizeTimeout) {
                    clearTimeout(this.resizeTimeout);
                }
                
                // Clean up card elements
                this.cards.forEach(card => {
                    if (card.element.parentElement) {
                        card.element.parentElement.removeChild(card.element);
                    }
                });
                
                this.deck.forEach(card => {
                    if (card.element.parentElement) {
                        card.element.parentElement.removeChild(card.element);
                    }
                });
            }
        }
        
        // Initialize the game
        let gameInstance;
        window.addEventListener('load', () => {
            gameInstance = new CardGamePlayground();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (gameInstance) {
                gameInstance.destroy();
            }
        });
    </script>
</body>
</html>
